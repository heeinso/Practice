# 암시적 강제변환

## 불리언

아래와 같은 컨텍스트에서 불리언 아닌 값이 사용되면, ToBoolean 추상 규칙에 따라 일단 불리언 값으로 암시적 강제변환된다

1. if \(\)문의 조건 표현식
2. for \( ; ; \)에서 두번째 조건 표현식
3. while \(\) 및 do ... while\(\) 루프의 조건 표현식
4. ?: 삼항 연산 시 첫번째 조건표현식
5. \|\| \(논리 OR\) 및 && \(논리 AND\)의 좌측 피연산자

```javascript
var a = 42;
var b = "abc";
var c;
var d = null;

if (a) {
    console.log("넵"); // 넵
}

while (c) {
    console.log("실행 안되겠지?");
}

c = d ? a : b;
c; // abc

if ((a && d) || c) {
    console.log("넵"); // 넵
}
```

## 느슨한/엄격한 동등 비교

많은 이들이 종종 "=="는 값의 동등함을, "==="는 값과 타입 모두의 동등함을 비교한다고 생각한다. 그럴듯하지만 정확하진 않다.

엄밀하게 말하면, 동등함의 비교시 "=="는 강제변환을 허용하지만 "==="는 강제변환을 허용하지 않는다

```javascript
var x = true;
var y = "42";

x == y; // false

var a = "42";
var b = false;

a == b; // false
```

Type\(x\)가 불리언이므로 ToNumber\(x\)는 1이고, "42" == 0 동등비교에서 \(재귀적으로\) 42 == 0가 되어 false로 평가된다

"42"는 분명 truthy 값이지만 "42" == true에서 "42"는 불리언\(true\)으로 강제변환되지 않고, 우선 true가 1로 강제변환된 후에 "42"는 42로 강제변환된다

**따라서 어떤 일이 있더라도, 절대로, 두 번 다시 ==true, ==false 같은 코드는 쓰지 말라**

```javascript
var a = "42";

if (a == true) {
    // 실패
}

if (a === true) {
    // 실패
}

if (a) {
    // 암시적으로 작동
}

if (!!a) {
    // 명시적으로 작동
}

if (Boolean(a)) {
    // 명시적으로 작동
}
```

## 암시적 강제변환의 안전한 사용법

* 피연산자 중 하나가 true/false일 가능성이 있으면 '절대로' == 연산자를 쓰지 말자
* 피연산자 중 하나가 \[\], " ", 0이 될 가능성이 있으면 가급적 == 연산자는 쓰지 말자

